"""
Identifier generation from metadata.

Generates deterministic, unique identifiers from normalized metadata
using cryptographic hash functions.
"""

import hashlib
from typing import Any, Literal, Optional

from .metadata.normalizer import Metadata, canonicalize_metadata, normalize_metadata

Algorithm = Literal["sha256", "sha1"]
Encoding = Literal["hex", "base64"]


class IdentifierResult:
    """
    Result of identifier generation.

    Attributes:
        identifier: Full identifier with algorithm prefix (e.g., "sha256:abc123...")
        short: Short version (first 8 characters of hash)
        algorithm: Hash algorithm used
        metadata: Optional normalized metadata (if includeMetadata=True)
    """

    def __init__(
        self,
        identifier: str,
        short: str,
        algorithm: str,
        metadata: Optional[Metadata] = None
    ) -> None:
        self.identifier = identifier
        self.short = short
        self.algorithm = algorithm
        self.metadata = metadata

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        result = {
            "identifier": self.identifier,
            "short": self.short,
            "algorithm": self.algorithm
        }

        if self.metadata:
            result["metadata"] = self.metadata.to_dict()

        return result


def generate_identifier(
    meta: dict[str, Any] | Metadata,
    algorithm: Algorithm = "sha256",
    encoding: Encoding = "hex",
    truncate: Optional[int] = None,
    include_metadata: bool = False
) -> IdentifierResult:
    """
    Generate a deterministic unique identifier from metadata.

    The identifier is generated by:
    1. Normalizing metadata to consistent format
    2. Canonicalizing to sorted JSON
    3. Hashing with specified algorithm
    4. Formatting with algorithm prefix

    Args:
        meta: Metadata dictionary or Metadata object
        algorithm: Hash algorithm ('sha256' or 'sha1', default: 'sha256')
        encoding: Output encoding ('hex' or 'base64', default: 'hex')
        truncate: Truncate hash to N characters (None for full hash)
        include_metadata: Include normalized metadata in result

    Returns:
        IdentifierResult with identifier, short version, and algorithm

    Raises:
        ValueError: If algorithm or encoding is invalid
        TypeError: If metadata is invalid

    Examples:
        >>> meta = {'source': 'local-git', 'owner': 'user', ...}
        >>> result = generate_identifier(meta)
        >>> result.identifier
        'sha256:abc123def456...'
        >>> result.short
        'abc123de'

        >>> result = generate_identifier(meta, algorithm='sha1', truncate=16)
        >>> result.identifier
        'sha1:abc123def456789a'
    """
    # Validate algorithm
    if algorithm not in ("sha256", "sha1"):
        raise ValueError(f"Invalid algorithm: {algorithm}. Must be 'sha256' or 'sha1'")

    # Validate encoding
    if encoding not in ("hex", "base64"):
        raise ValueError(f"Invalid encoding: {encoding}. Must be 'hex' or 'base64'")

    # Normalize metadata if needed
    if isinstance(meta, dict):
        normalized = normalize_metadata(meta)
    elif isinstance(meta, Metadata):
        normalized = meta
    else:
        raise TypeError(f"Invalid metadata type: {type(meta)}")

    # Create canonical JSON representation
    canonical = canonicalize_metadata(normalized)

    # Generate hash
    hash_obj = hashlib.new(algorithm)
    hash_obj.update(canonical.encode("utf-8"))

    # Get digest in specified encoding
    if encoding == "hex":
        hash_value = hash_obj.hexdigest()
    else:  # base64
        hash_value = hash_obj.digest().hex()  # Python's hashlib doesn't have base64 directly
        # Convert hex to base64
        import base64
        hash_bytes = bytes.fromhex(hash_value)
        hash_value = base64.b64encode(hash_bytes).decode("ascii")

    # Create identifier with algorithm prefix
    if truncate and isinstance(truncate, int) and truncate > 0:
        identifier = f"{algorithm}:{hash_value[:truncate]}"
    else:
        identifier = f"{algorithm}:{hash_value}"

    # Generate short version (first 8 characters of hash)
    short = hash_value[:8]

    # Create result
    result = IdentifierResult(
        identifier=identifier,
        short=short,
        algorithm=algorithm,
        metadata=normalized if include_metadata else None
    )

    return result


def generate_identifiers(
    metadata_array: list[dict[str, Any] | Metadata],
    algorithm: Algorithm = "sha256",
    encoding: Encoding = "hex",
    truncate: Optional[int] = None,
    include_metadata: bool = False
) -> list[IdentifierResult]:
    """
    Generate identifiers for multiple metadata objects.

    Args:
        metadata_array: List of metadata dictionaries or Metadata objects
        algorithm: Hash algorithm
        encoding: Output encoding
        truncate: Truncate hash to N characters
        include_metadata: Include normalized metadata in results

    Returns:
        List of IdentifierResult objects

    Examples:
        >>> metas = [meta1, meta2, meta3]
        >>> results = generate_identifiers(metas)
        >>> [r.identifier for r in results]
        ['sha256:abc...', 'sha256:def...', 'sha256:ghi...']
    """
    if not isinstance(metadata_array, list):
        raise TypeError("metadata_array must be a list")

    return [
        generate_identifier(
            meta,
            algorithm=algorithm,
            encoding=encoding,
            truncate=truncate,
            include_metadata=include_metadata
        )
        for meta in metadata_array
    ]


__all__ = [
    "Algorithm",
    "Encoding",
    "IdentifierResult",
    "generate_identifier",
    "generate_identifiers",
]
